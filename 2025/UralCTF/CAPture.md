Приветствую тебя читатель. Совсем недавно участвовал на **UralCTF** и наткнулся на достаточно интересную таску в моей любимой категории reverse. Вот она:

![Описание таски]( images/task.png)

В предоставленном архиве нас ожидает PE файл capture.exe. Давай запустим его:

![Главное окно программы](images/{7D78B6F6-6288-4E0F-AF1F-52B5075EA41D}.png)

Нас встречает проверка пароля и какого то секретного ключа. Не густо.

Первое что я делаю, когда встречаю неизвестный мне файл, чтобы чуть лучше понять что он из себя представляет - отправляю его в **Detect It Easy**.

![Результат анализа в Detect It Easy](images/{5B32C0D4-482C-4554-9549-A8FEA0F00D2C}.png)

Отлично. Теперь мы знаем, что программа была написана на C#(C# компилируется в промежуточный язык (Intermediate Language, IL), который затем выполняется на платформе .NET. Этот IL сохраняет много информации о структуре программы, что облегчает декомпиляцию.). Для того чтобы получить декомпил C# существует куча инструментов:
**ILSpy**, **dotPeek**, **Reflector**, **JustDecompile** и **dnSpy**. На своём небольшом пути реверсера мне  доводилось пользоваться **dnSpy**. 
На мой взгляд он достаточно популярен и очень удобен, поэтому им я воспользуюсь и сейчас:

![Интерфейс dnSpy](images/{7B3C2774-21A5-4E5F-954A-607EFA8CD2EA}.png)

Посмотрим на метод `button1_Click`:

![Метод button1_Click](images/{7F39AAB1-3DA5-4C11-B6A6-BCA481190D92}.png)

Это обработчик нажатия кнопки. Записанный нами пароль передаётся некоему методу `Z()`, который в свою очередь выдаёт вердикт о правильности пароля, а затем происходят какие то действия с формированием сида. Сложно как то... Посмотрим на метод `button2_Click`, который судя по названию является обработчиком нажатия на вторую кнопку:

![Метод второй кнопки](images/{F215A574-6353-49A3-9789-4D8D99193CB2}.png)

Хммм... Вот это выглядит уже куда легче. Здесь мы видим проверку введённого UUID. Если он не правильный, то происходит возрат из метода. Если же проверка проходит, то вызывается метод `W()` и выводится текст `Куда же он подевался...`. Выглядит как то, что можно попробовать запатчить. Но для начала посмотрим на метод `W()`:

![Метод W()](images/{17EEA92C-146A-468C-9CBE-6FDC9D5A1BCC}.png)

Теперь становится понятно, почему автор в описании таски упомянул дроппер. Здесь создаётся файл `qt-installer-framework.cache`, по такому пути: 
`%AppData%\Local\cache\qt-installer-framework\`
На моей виртуальной машине он будет выглядеть так:
`C:\Users\user\AppData\Local\cache\qt-installer-framework`
Затем мы видим декодирование данных полученных с `Json()`. Посмотрим что внутри загадочного метода `Json()`:

![Метод Json()](images/{CE61D5B6-C4F9-4029-BE22-7BF89D8B73DD}.png)

Мы видим, что метод `Json()` возвращает строку, которая формируется из `this.B` с помощью `string.Concat(this.B)`. Посмотрим что из себя представляет это поле `B`:

![Поле B](images/{0EE37701-099E-4177-AE3B-C718730DFDB1}.png)

Судя по всему это байты PE файла, закодированные в base64. Программа в случае, если мы вводим верные данные, сбрасывает PE файл по пути `C:\Users\user\AppData\Local\cache\qt-installer-framework\qt-installer-framework.cache`.
Теперь попробуем запатчить. Сделать мы это можем непосредственно в **dnSpy**. Просто уберем код с проверкой в обработчике 2 кнопки:

![Патч в dnSpy](images/{DF759F87-093F-490E-822F-908A4DA01770}.png)

Запустим программу и убедимся, что патч работает:

![Работающий патч](images/{ADB460E0-D530-4456-B94A-41B32BF5EDB7}.png)

Отлично. Перейдём по пути и убедимся, что файл сбросился:

![Сброшенный файл](images/{81A47F42-E629-4124-9F41-24EF86796830}.png)

Посмотрим, что из себя представляет сброшенный файл поближе. Для этого можно воспользоваться **IDA/Ghidra/Binja** etc... Я предпочитаю золотую классику **IDA**:

![Анализ в IDA](images/{581A33E4-58C6-41E7-BA6F-11F3EFD18757}.png)

как я и предпологал, определила, что мы имеем дело с PE файлом. Перейдём на функцию `start`:

![Функция start](images/{A4DBC824-E4FF-45AF-8D5E-D6809D56730D}.png)

Мы можем увидеть строки "Final Stage", "Welcome to the Final Stage!" и... НИЧЕГО! Реально ничего. Файл даже не запускается... Но мы не сдаёмся, мы сделаны из стали. Попробуем открыть дропнутый файл в hex-редакторе. Я предпочитаю ныне популярный **ImHex**. Немного покрутив ползунок, я наткнулся на такие байты:

![Найденные байты](images/{FE88460A-7193-4925-9896-64619665B798}.png)

После нескольких попыток применить различные алгоритмы дешифровки, я обратил внимание на название таски - "CAPture". 

Попробовав использовать строки, связанные с именем таски, в качестве ключа для XOR-шифрования, я обнаружил, что ключ "CAPtureMe" успешно расшифровывает данные в читаемый текст, содержащий флаг. Вот сами байты с флагом:

![Байты флага](images/{97444DB0-7549-41D9-B4D9-31EF994BABAD}.png)

А вот скрипт для дешифровки:

```python
encrypted_data = bytes([
    0x16, 0x33, 0x31, 0x18, 0x36, 0x26, 0x23, 0x36, 0x11, 0x72, 0x2F, 0x29, 0x2B, 0x11, 0x00,
    0x55, 0x3D, 0x15, 0x70, 0x33, 0x23, 0x2B, 0x44, 0x1C, 0x3A, 0x20, 0x1C, 0x1C, 0x27, 0x60,
    0x06, 0x18, 0x47, 0x18
])

key = b"CAPtureMe"

decrypted = []
for i in range(len(encrypted_data)):
    decrypted_byte = encrypted_data[i] ^ key[i % len(key)]
    decrypted.append(decrypted_byte)

flag = bytes(decrypted).decode('utf-8', errors='ignore')
print(flag)
